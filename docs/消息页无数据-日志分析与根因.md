# 消息页和二级页无数据 - 日志分析与根因

## 0. 传参日志与 openId 修复（便于排查 ID 问题）

已在以下位置补充**传参日志**（openId 脱敏），并修复 getMessagesNew 的 **openId 取值**，便于确认是否为 ID 传递问题。

| 位置 | 日志内容 |
|------|----------|
| **apiServer** `AppService.handleApiRequest` | 消息接口：`operation, openId(尾4), openId空, dataEnv, page, limit, type, from, aitType` |
| **apiServer** `callAppApiCloudFunction` | 消息接口转发：`data(传云函数)` 的 page/limit/type/from/aitType |
| **appApi** `GetMessageList` | 传参：`openId(尾4), openId类型/长度/空`；`dataEnv, page, limit, type, from, aitType`；调用核心层前 `coreParams(脱敏)` |
| **getMessagesNew** 入口 | `event 键`；`dataEnv, envId`；**openId(尾4)、来源(event.openId / wxContext.OPENID)、类型、长度**；`type, page, limit, from, groupType, aitType` |

**openId 逻辑修复**（`getMessagesNew/index.js`）：  
- appApi 调用时只传 `openId` 不传 `source`，原先会误用 `wxContext.OPENID`（云函数互调时可能为空）。  
- 现改为：**只要 `event.openId` 有值就优先使用**，否则再回退到 `wxContext.OPENID`，保证 appApi → getMessagesNew 链路的 openId 正确。

---

## 1. 日志现象小结

| 现象 | 说明 |
|------|------|
| 请求 | 首屏：`page=1, limit=20, type=nil`；分类：`type=3/4/5/11` 等，均带 `dataEnv=prod`、有 Token |
| HTTP | `status: 201`，`duration: ~11s` |
| API | `operation: getMessagesNew, code: 200, hasData: true` |
| 数据 | **首屏/分类均：`messages=0, count=0, isEmpty=true, allLoaded=false`** |

结论：**接口 200、hasData 为 true，但业务数据为空**——服务端返回的 `data` 里 `messages` 为空数组、`count` 为 0。

---

## 2. 数据链路（当前实际路径）

1. **客户端**  
   `MessageViewModel` / `MessageCategoryViewModel` → `NetworkService.request(operation: "getMessagesNew", data: { page, limit, type? }, dataEnv: AppConfig.dataEnv)`  
   请求发往：**Cloud Run apiServer**  
   `https://juqi-api-server-xxx.run.tcloudbase.com/app/v2/api`

2. **Cloud Run (apiServer)**  
   - `shouldUseDirectDB("getMessagesNew")` 为 **false**（迁移配置里没有 `getMessagesNew`，只有 `appGetMessageList` 等）  
   - 因此走 **callAppApiCloudFunction**，把 `operation: "getMessagesNew"`、`data`、`dataEnv` 等原样传给 **appApi 云函数**。

3. **appApi 云函数**  
   - 将 `getMessagesNew` 映射为 `appGetMessageList`，执行 **GetMessageList**。  
   - GetMessageList 从 event 取 `dataEnv`，写入 `coreParams.dataEnv`，再 **callFunction('getMessagesNew', coreParams)**。  
   - 若 getMessagesNew 返回 `code !== 200`，appApi 会**统一转成空数据**返回：  
     `success({ messages: [], count: 0, notReadCount })`（见 `appApi/modules/message.js` 137–145 行）。

4. **getMessagesNew 云函数**  
   - 根据 `event.dataEnv` 做 `cloud.init({ env: PROD_ENV_ID / TEST_ENV_ID })`，设置 `global.__GETMESSAGESNEW_DB__`。  
   - 首屏（type 为 nil/2）走 **getMessagesUser**，分类走 **getChargeMessage / getCommentMessage / getVisitMessage / getAitMes** 等，内部均通过 **getDb()** 使用上面注入的 db。

因此：**“消息页和二级页没有数据” = 客户端拿到的就是服务端下发的空列表**，问题在服务端返回空，而不是客户端解析错误。

---

## 3. 可能根因（按优先级）

### 3.1 getMessagesNew 返回了非 200，被 appApi 转成空（优先查）

- **位置**：`cloudfunctions/appApi/modules/message.js`  
  - 若 `result.result.code && result.result.code !== 200`，直接返回 `messages: [], count: 0`。  
- **可能触发**：  
  - getMessagesUser / getChargeMessage 等子模块 **catch 里 return { code: 400, message: '查询失败' }**（如 `getMessagesUser.js` 99–104 行）。  
  - 聚合或 DB 报错、权限、集合名/字段与当前环境不一致等，都会导致返回 400，进而被 appApi 转成空。

**建议**：在云函数日志中查 `[getMessagesNew]`、`[appGetMessageList]`：  
- 是否有 `code: 400` 或 “查询失败”；  
- `[appGetMessageList] 核心层返回 rawMessages.length=?, count=?` 的实际值。

### 3.2 dataEnv 未传到 getMessagesNew 或环境切错

- 若 **dataEnv 未传到 getMessagesNew**，入口会用默认 `dataEnv = 'test'`，查的是**测试环境 DB**；若该用户在测试环境本来就没有消息，就会一直返回空。  
- 需确认：  
  - apiServer 调用 appApi 时是否带上 `dataEnv`（已确认 controller 从 body 取 `dataEnv` 并传入）；  
  - appApi 的 GetMessageList 是否把 `event.dataEnv` 写入 `coreParams.dataEnv`（已实现）；  
  - getMessagesNew 入口日志 `[getMessagesNew] dataEnv:, envId:` 在线上请求里是否为 **dataEnv=prod、envId=生产环境 ID**。

### 3.3 生产环境该用户确实无消息

- 首屏查的是 `messagesType`（getMessagesUser），分类查的是 `messagesOther` 等；若生产库该 openId 下确实没有对应记录，也会返回 0 条。  
- 需在**生产 DB** 中抽查：  
  - `messagesType` 中 `to = 当前用户 openId` 是否有数据；  
  - `messagesOther` 等是否也有对应 type 的数据。

### 3.4 云函数内未捕获异常导致返回异常结构

- 若 getMessagesNew 或子模块抛错，且未被正确 catch，可能返回非预期结构；appApi 侧若对 `result.result` 解析不当，也可能走到“返回空”的分支。  
- 云函数日志中若有未捕获异常或堆栈，可对应排查。

---

## 4. 建议排查步骤

1. **看云函数日志（优先）**  
   - 环境：**测试环境**（appApi、getMessagesNew 部署处）。  
   - 筛选：`getMessagesNew`、`appGetMessageList`。  
   - 关注：  
     - `[getMessagesNew] dataEnv: ?, envId: ?` → 确认是否为 prod 及正确 envId。  
     - `[getMessagesNew] type=2 首屏 messages.length=?, count=?` 或 `type=nil 默认首屏` 等 → 确认核心层是否本身就返回 0。  
     - `[appGetMessageList] 核心层返回 rawMessages.length=?, count=?, notReadCount=?` → 确认 appApi 收到的条数。  
     - 是否有 `[appGetMessageList] 核心层返回错误，返回空数据` 或 `code !== 200` 的日志。

2. **确认 dataEnv 传递链**  
   - 客户端：日志里已有 `dataEnv=prod`（请求 body）。  
   - 若云函数里看到 `dataEnv: test` 或未出现 dataEnv，则需检查 apiServer → appApi 的入参是否把 body 里的 dataEnv 带到 event。

3. **核对生产库数据**  
   - 用当前登录用户的 openId，在生产环境 DB 查：  
     - `messagesType`：`to = openId`；  
     - `messagesOther`：`to = openId` 及各 type。  
   - 若无数据，则“无数据”是符合预期的，需从业务上确认是否应有消息（例如是否有写消息的流程、是否写错环境等）。

4. **（可选）临时加日志**  
   - 在 **appApi GetMessageList** 中：  
     - 在调用 getMessagesNew 后打印 `result.result`（可脱敏），或至少打印 `result.result.code`、`result.result.messages?.length`、`result.result.count`。  
   - 在 **getMessagesNew 入口**：  
     - 打印 `event.dataEnv`、`event.openId`（尾 4 位）及即将使用的 `envId`。  
   - 便于下次复现时直接确认“核心层返回是否就为空”或“是否被转成空”。

---

## 5. 与现有文档的对应关系

- **消息页数据链路排查与修复**（`消息页数据链路排查与修复.md`）：  
  - 已说明 dataEnv 传递、getMessagesNew 内 getDb() 与 env 切换；  
  - 本次问题是在该链路基础上，**进一步确认“谁在返回空”**（核心层 400/空，还是 appApi 转成空）。  
- **消息 tab 不请求 + 二级页无数据**（同文档“补充修复”）：  
  - 已修复首屏空结果导致 allLoaded 锁死、以及二级页 type 用错（如充电用成 5）；  
  - 当前日志显示**请求在发、类型正确**（type=3/4/5/11），问题集中在**服务端返回空**。

---

## 6. 小结

| 项目 | 结论 |
|------|------|
| 客户端 | 请求正常（含 dataEnv=prod、Token、type）；解析正常（messages=0, count=0 来自服务端 data） |
| 服务端 | 返回 200 + data 存在，但 data.messages 为空、data.count 为 0 |
| 最可能原因 | getMessagesNew 返回 code!==200 被 appApi 转成空；或 dataEnv 未生效查到测试库；或生产库该用户无消息 |
| 下一步 | 查云函数日志确认 dataEnv、openId、核心层 messages.length/count 及是否有“返回空数据”的日志；必要时查生产 DB 与临时加日志 |

---

## 7. 云函数日志排查结果（2026-02-11）

通过 CloudBase MCP 拉取 **getMessagesNew** 近期调用，确认了 **App 的调用链** 与根因。

### 7.1 App 调用已命中

- **RequestId e9924914**（00:15:42）、**2afb2480**（00:15:30）、**3c0aae65**（00:15:29）等：
  - **event**：`dataEnv: 'prod'`, `openId: 'onosB5lRKgCjonoNbj9peqM--e2Q'`, `page: 1`, `limit: 20`（首屏无 type），或 `type: 11, aitType: 1`（艾特）。
  - 说明 **appApi 传入的 openId、dataEnv 已正确到达 getMessagesNew**，ID 与传参无误。

### 7.2 根因：云函数超时，非 ID 问题

- 首屏（e9924914）：
  - getMessagesUser 执行，**count 查到 total: 64052**（该用户消息量很大）。
  - 随后日志：**"Your current request database.calculateDocument is longer than 3s"**（聚合/查询超过 3 秒）。
  - 最终：**"Invoking task timed out after 10 seconds"**，返回 **statusCode: 433**。
- 艾特（3c0aae65）：同样出现 **database.calculateDocument is longer than 3s**，存在超时风险。

**结论**：消息页无数据不是因为 openId 或 dataEnv 传错，而是 **getMessagesNew 在首屏/分类查询时，聚合（getMessagesUser 或 getAitMes 等）在数据量大时执行超过 10 秒，云函数超时**。超时后客户端可能收到错误或空数据。

### 7.3 建议

1. **治标**：将 getMessagesNew 云函数 **超时时间调大**（如 20s 或 30s），注意云函数最大限制。
2. **治本**：优化 **getMessagesUser** 等聚合：
   - 为 `messagesType` 的 `to`、`status`、`createTime` 等加索引；
   - 减少不必要的 lookup 或分阶段查询；
   - 或先分页取 id 再按 id 批量查详情，避免单次大聚合。

---

## 8. 小程序 vs App：消息处理的实际差异（代码与调用链对比）

以下为代码与调用链的客观对比，不包含推测。

### 8.1 调用链

| 环节 | 小程序（JUQI-小程序） | App（JUQI-APP） |
|------|------------------------|------------------|
| 入口 | `getApp().callCloud2({ operation: "getMessagesNew", data: { page, limit, type? } })` | `NetworkService.request(operation: "getMessagesNew", data: { page, limit, type?, from?, aitType? })` |
| 实际请求 | `wx.cloud.callFunction({ name: "getMessagesNew", data: { page, limit, type? } })`（见 `miniprogram/utils/request.js`：platform 为 WeChat 时 callFunction = data.operation，callData = data.data） | HTTP POST `AppConfig.baseURL`（Cloud Run：juqi-api-server-xxx.run.tcloudbase.com）body：`operation`, `data`, `source: "v2"`, `dataEnv: AppConfig.dataEnv`, `token` |
| 到达的云函数 | 直接到 **getMessagesNew**（与小程序绑定的同一云环境） | 先到 **appApi**（仅部署在测试环境），appApi 内 `cloud.callFunction({ name: "getMessagesNew", data: coreParams })` 再到 **getMessagesNew**（同属测试环境） |

### 8.2 请求参数

| 参数 | 小程序 | App |
|------|--------|-----|
| 传参内容 | 仅 `data`: `{ page, limit }` 或 `{ page, limit, type }` / `{ page, limit, type, aitType }` 等 | body 顶层：`operation`, `data`（同上）, `source: "v2"`, `dataEnv: AppConfig.dataEnv`, `token` |
| openId | 不传；云函数内用 `wxContext.OPENID` | 不直接传；appApi 从 token 解析后写入 coreParams.openId 再传 getMessagesNew |
| dataEnv | 不传 | 传 `dataEnv`（如 prod）；getMessagesNew 用 `event.dataEnv \|\| 'test'` 决定 init 哪套环境 |

### 8.3 getMessagesNew 云函数代码差异

| 项目 | 小程序（JUQI-小程序/cloudfunctions/getMessagesNew） | App（JUQI-APP/cloudfunctions/getMessagesNew） |
|------|------------------------------------------------------|-------------------------------------------------|
| 入口 env | 无 dataEnv；顶部 `cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV })`，全程用当前环境 | `dataEnv = event.dataEnv \|\| 'test'`；`cloud.init({ env: envId })`（PROD_ENV_ID / TEST_ENV_ID）；`global.__GETMESSAGESNEW_DB__ = cloud.database()` |
| openId | `openId = event.source === 'newApp' ? event.openId : wxContext.OPENID` | 优先 `event.openId`，否则再走 source/newApp 或 wxContext.OPENID |
| 子模块用 DB | getMessagesUser.js 等顶层 `const db = cloud.database()`，无 getDb()，固定当前环境 | 子模块内 `const db = getDb()`，getDb() 用 `global.__GETMESSAGESNEW_DB__`（按 dataEnv 切换后的 db） |
| 使用的库 | **当前云环境对应的库**（小程序绑生产则生产库） | **由 dataEnv 决定**（App 传 prod 则读生产库；云函数本身部署在测试环境） |

### 8.4 云函数运行与部署环境

| 项目 | 小程序 | App |
|------|--------|-----|
| getMessagesNew 部署位置 | 小程序项目部署到其绑定的云环境（用户确认为生产库，即生产环境） | JUQI-APP/cloudbaserc.json：envId 为 **test-juqi-3g1m5qa7cc2737a1**（测试环境） |
| getMessagesNew 实际运行环境 | 与小程序同环境（生产） | 与 appApi 同环境（测试）；通过 dataEnv=prod 读生产库 |

### 8.5 小结（事实汇总）

- **调用路径**：小程序直调 getMessagesNew；App 经 Cloud Run → appApi → getMessagesNew。
- **参数**：小程序不传 dataEnv、不传 openId（用微信上下文）；App 传 dataEnv、appApi 传 openId。
- **云函数实现**：小程序版无 dataEnv 逻辑，用当前环境 db；App 版有 dataEnv 与 getDb()，可读生产库。
- **运行/部署**：小程序侧 getMessagesNew 部署并运行在生产环境；App 侧 getMessagesNew 部署并运行在测试环境，仅通过参数读生产库。

### 8.6 基于上述差异，为何 App 查不出数据

- **根本原因**：App 调用的 getMessagesNew **跑在测试环境**（8.1/8.4），而测试环境该实例的**执行超时时间为 10 秒**（日志：`Invoking task timed out after 10 seconds`，statusCode 433）。同一请求在生产库上会触发 getMessagesUser 的聚合（messagesType 等），当该用户数据量很大（如 6.4 万条）时，聚合超过 10s → 被平台杀掉 → 返回超时/空，前端表现为无数据。
- **与差异的对应关系**：
  - **运行环境不同**（8.4）：小程序侧 getMessagesNew 运行在**生产环境**，超时配置通常更长（如 30s）或相同慢查询在生产环境内完成；App 侧 getMessagesNew 运行在**测试环境**，实测 10s 超时。因此「同一生产库、同一类慢查询」在小程序侧能跑完，在 App 侧被 10s 限时杀掉。
  - **调用链不同**（8.1）：App 多了一层 appApi，getMessagesNew 只能由测试环境的 appApi 在同环境内 callFunction，无法改为跑在生产环境，所以无法享受生产环境上 getMessagesNew 的超时配置。
- **结论**：App 查不出数据，是因为**执行 getMessagesNew 的云函数在测试环境且 10s 超时**，而该次查询（生产库、大数量用户）需要更长时间；与 openId/dataEnv 传参、接口逻辑无关。
