# App接口架构设计文档

## 一、架构设计原则

### 1.1 完全隔离原则
- App接口与小程序接口完全独立
- 通过新建`appApi`云函数作为App专用入口
- App不直接调用小程序使用的云函数
- 小程序不受任何影响

### 1.2 数据共享原则
- App与小程序共享同一数据库
- 确保数据完全一致
- 会员状态字段完全一致

### 1.3 统一入口原则
- 所有App接口通过`appApi`云函数统一调用
- 统一的Token验证机制
- 统一的响应格式

## 二、架构设计

### 2.1 接口调用流程

```
┌──────────────┐
│ iOS App客户端 │  ← 入口层：请求发起
└──────┬───────┘
       ↓
┌──────────────┐
│  appApi入口   │  ← 客户端层：入口/鉴权/参数适配
│  (Token验证)  │     - 统一入口
│  (参数校验)   │     - Token验证
│  (响应格式化) │     - 参数适配
└──────┬───────┘
       ↓
┌──────────────┐
│  业务版本层   │  ← 业务版本层：真正的差异在这里
│  (modules)    │     - App特有的业务逻辑
│  auth/user/   │     - 数据格式转换
│  dyn/circle/  │     - 业务规则差异处理
│  message等    │     - 可独立扩展，不影响小程序
└──────┬───────┘
       ↓
┌──────────────┐
│  业务核心层   │  ← 业务核心层：能共用就共用
│  现有云函数   │     - 核心业务逻辑
│  (login/      │     - 数据库操作
│   getDyns等)  │     - 通过source参数隔离
└──────┬───────┘
       ↓
┌──────────────┐
│  共享数据库   │  ← 数据层：共享数据存储
└──────────────┘
```

### 2.2 云函数结构设计

```
cloudfunctions/appApi/
├── index.js              # 客户端层：入口文件，路由分发、鉴权、参数适配
├── modules/              # 业务版本层：App特有的业务逻辑处理
│   ├── auth.js          # 认证模块（登录、注册、Token）
│   │                     # - App登录逻辑差异处理
│   │                     # - Token生成和验证
│   │                     # - 调用业务核心层login云函数
│   ├── user.js          # 用户模块（用户信息、会员状态）
│   │                     # - App用户信息格式转换
│   │                     # - 会员状态处理
│   │                     # - 调用业务核心层getUserAbout等
│   ├── dyn.js           # 动态模块（动态列表、详情、发布、互动）
│   │                     # - App动态列表格式适配
│   │                     # - App特有的业务规则
│   │                     # - 调用业务核心层getDynsListV2等
│   ├── circle.js        # 圈子模块（圈子列表、详情、加入）
│   ├── message.js       # 消息模块（消息列表、聊天）
│   ├── search.js        # 搜索模块（用户、动态、话题搜索）
│   └── upload.js        # 上传模块（图片上传）
├── core/                 # 业务核心层：可复用的核心业务逻辑（可选）
│   └── ...              # 如果需要在appApi内部封装核心逻辑
├── utils/                # 工具函数
│   ├── token.js         # Token验证工具
│   ├── response.js      # 响应格式化工具
│   └── error.js         # 错误处理工具
└── package.json         # 依赖配置
```

**架构层次说明**：
- **客户端层（index.js）**：负责入口、鉴权、参数适配、响应格式化
- **业务版本层（modules/）**：负责App特有的业务逻辑差异处理
  - 可以独立实现App特有的业务逻辑
  - 可以调用业务核心层，也可以直接操作数据库
  - 可以转换数据格式，适配App需求
- **业务核心层（现有云函数）**：负责核心业务逻辑，不区分调用来源
  - 接收标准化参数，不接收source参数
  - 专注于核心业务逻辑，保持代码纯净
  - 可被所有版本复用，无需修改

### 2.3 与现有云函数的关系

**核心设计原则：版本控制，而非source判断**

**调用关系**:
- **业务版本层（modules）**负责：
  1. **参数标准化**：将App请求参数转换为核心层标准格式
  2. **身份处理**：App通过Token解析openId，小程序通过wxContext获取
  3. **数据转换**：将核心层返回数据转换为App所需格式
  4. **业务差异**：处理App特有的业务逻辑差异
- **业务核心层（现有云函数）**：
  - **不接收source参数**，不区分调用来源
  - 只接收标准化参数（openId、业务参数等）
  - 专注于核心业务逻辑，保持纯净
  - 可被多个版本复用，无需修改

**版本控制实现方式**:
```
App请求 → 业务版本层（modules）
  ↓
1. Token验证，解析openId
2. 参数标准化（将App参数转为核心层标准格式）
3. 调用核心层（传递标准化参数，不传source）
  ↓
核心层（现有云函数）
  ↓
1. 接收标准化参数
2. 执行核心业务逻辑
3. 返回标准数据
  ↓
业务版本层（modules）
  ↓
1. 数据格式转换（适配App需求）
2. 添加App特有字段
3. 返回给App客户端
```

**架构优势**:
- **单一职责**：核心层只负责核心业务，不关心调用来源
- **可维护性**：核心层无需if-else判断，代码更清晰
- **可扩展性**：未来新增版本（H5、Android等），核心层无需修改
- **隔离性**：App和小程序完全隔离，互不影响
- **复用性**：核心层可被所有版本复用，代码复用率更高

**隔离保证**:
- App客户端只调用appApi云函数
- appApi的业务版本层处理所有App特有逻辑
- 调用核心层时传递标准化参数，不传source
- 小程序直接调用现有云函数，不受影响
- 核心层保持纯净，不区分来源

## 三、接口分类和映射

### 3.1 接口分类映射表

| App接口名称 | 对应现有云函数 | 模块分类 | 说明 |
|------------|--------------|---------|------|
| appLogin | login | auth | 登录接口 |
| appGetUserInfo | login (userinfo) | auth | 获取用户信息 |
| appGetCurrentUser | login (getOwnInfo) | user | 获取当前用户 |
| appGetUserProfile | getUserAbout | user | 获取用户主页 |
| appUpdateUserInfo | updateUserInfo | user | 更新用户信息 |
| appGetDynList | getDynsListV2 | dyn | 获取动态列表 |
| appGetDynDetail | getDynDetail | dyn | 获取动态详情 |
| appPublishDyn | publishDyn | dyn | 发布动态 |
| appDeleteDyn | delDyn | dyn | 删除动态 |
| appLikeDyn | likeOrUnlikeV2 | dyn | 点赞动态 |
| appCommentDyn | commentV2 | dyn | 评论动态 |
| appGetComments | getDynComment | dyn | 获取评论列表 |
| appGetCircleList | getCircle | circle | 获取圈子列表 |
| appGetCircleDetail | getCircleDetail | circle | 获取圈子详情 |
| appJoinCircle | setJoinCircle | circle | 加入圈子 |
| appQuitCircle | setJoinCircle (type=2) | circle | 退出圈子 |
| appGetMessageList | getMessagesNew | message | 获取消息列表 |
| appGetChatHistory | chat | message | 获取聊天记录 |
| appSendMessage | chat/setMessage | message | 发送消息 |
| appSearchUser | getRearch | search | 搜索用户 |
| appSearchDyn | getRearch | search | 搜索动态 |
| appSearchTopic | getRearch | search | 搜索话题 |
| appUploadImage | upload | upload | 上传图片 |
| appGetTopicList | getTopic | other | 获取话题列表 |
| appFollowUser | followOrUnfollow | other | 关注用户 |
| appUnfollowUser | followOrUnfollow | other | 取消关注 |
| appGetConfig | getInfo | other | 获取配置信息 |

### 3.2 接口实现方式

**版本控制实现模式**：

**方式一：参数标准化调用**
```javascript
// 业务版本层（modules/dyn.js）
async function appGetDynList(event) {
  // 1. Token验证，解析openId
  const { openId } = await verifyToken(event.token);
  
  // 2. 参数标准化（将App参数转为核心层标准格式）
  const coreParams = {
    openId: openId,
    ownOpenId: openId,  // App版本在版本层处理openId
    type: event.data.type,
    // ... 其他标准化参数
    // 注意：不传递source参数
  };
  
  // 3. 调用核心层（传递标准化参数）
  const coreResult = await cloud.callFunction({
    name: 'getDynsListV2',
    data: coreParams  // 不包含source
  });
  
  // 4. 数据格式转换（适配App需求）
  return formatAppResponse(coreResult);
}
```

**方式二：独立实现App特有逻辑**
```javascript
// 如果App有完全不同的业务逻辑，在版本层独立实现
async function appGetDynList(event) {
  // App特有的业务逻辑
  // 直接操作数据库，不调用核心层
  const db = cloud.database();
  // ... App特有实现
}
```

**方式三：组合调用多个核心层函数**
```javascript
// 对于复杂业务，组合调用多个核心层函数
async function appGetUserProfile(event) {
  const { openId } = await verifyToken(event.token);
  
  // 组合调用多个核心层函数
  const [userInfo, stats, relations] = await Promise.all([
    cloud.callFunction({ name: 'getUserAbout', data: { openId } }),
    cloud.callFunction({ name: 'getUserStats', data: { openId } }),
    cloud.callFunction({ name: 'getUserRelations', data: { openId } })
  ]);
  
  // 组合并转换数据格式
  return formatAppUserProfile(userInfo, stats, relations);
}
```

**核心层改造说明**：
- 现有云函数需要移除source参数判断逻辑
- 统一接收标准化参数（openId、ownOpenId等）
- App版本在版本层通过Token解析openId
- 小程序版本通过wxContext获取openId
- 核心层不关心openId来源，只使用openId执行业务逻辑

## 四、Token验证机制

### 4.1 Token获取
- 登录接口返回Token
- Token存储在App本地（Keychain）
- Token有效期：30天

### 4.2 Token验证
- 需要认证的接口必须携带Token
- appApi入口验证Token有效性
- Token无效返回401错误

### 4.3 Token刷新
- 提供Token刷新接口
- Token即将过期时自动刷新
- 刷新失败需要重新登录

## 五、会员状态处理

### 5.1 会员状态获取
- 登录时获取会员状态
- 获取用户信息时获取会员状态
- 会员状态实时从服务器获取

### 5.2 会员状态字段
- vipStatus: Boolean
- vipStartTime: Number (时间戳，毫秒)
- vipEndTime: Number (时间戳，毫秒)
- vipConfig: Object

### 5.3 会员状态同步
- 所有返回用户信息的接口必须包含会员状态
- 会员状态字段位置统一
- 会员状态判断逻辑与小程序一致

## 六、错误处理机制

### 6.1 统一错误码
- 200: 成功
- 400: 请求参数错误或业务错误
- 401: Token无效或未登录
- 403: 无权限
- 500: 服务器错误

### 6.2 错误信息格式
```json
{
  "code": 400,
  "message": "错误描述信息",
  "data": null
}
```

### 6.3 错误处理流程
- appApi入口统一捕获错误
- 格式化错误响应
- 返回统一格式的错误信息

## 七、数据格式规范

### 7.1 请求格式
```json
{
  "operation": "接口名称",
  "data": {
    "参数1": "值1",
    "参数2": "值2"
  },
  "token": "用户Token" // 需要认证的接口必须携带
}
```

### 7.2 响应格式
```json
{
  "code": 200,
  "data": {
    "数据内容"
  },
  "message": "成功"
}
```

### 7.3 会员状态返回格式
```json
{
  "code": 200,
  "data": {
    "userInfo": {
      "usersSecret": [{
        "vipStatus": true,
        "vipStartTime": 1234567890000,
        "vipEndTime": 1234567890000,
        "vipConfig": {}
      }]
    }
  }
}
```

## 八、接口隔离实现（版本控制方案）

### 8.1 版本控制隔离方式

**核心原则：版本层处理差异，核心层保持纯净**

1. **App版本（appApi）**
   - App客户端只调用appApi云函数
   - appApi的业务版本层处理所有App特有逻辑
   - 调用核心层时传递标准化参数，不传source
   - 在版本层通过Token解析openId

2. **小程序版本**
   - 小程序直接调用现有云函数
   - 通过wxContext获取openId
   - 不经过appApi，完全独立

3. **核心层（现有云函数）**
   - 不接收source参数
   - 不区分调用来源
   - 只接收标准化参数（openId、业务参数等）
   - 专注于核心业务逻辑

### 8.2 版本控制实现示例

**示例：获取动态列表**

```javascript
// ========== 业务版本层（appApi/modules/dyn.js）==========
async function appGetDynList(event) {
  // 1. Token验证，解析openId（App版本特有）
  const { openId } = await verifyToken(event.token);
  
  // 2. 参数标准化
  const coreParams = {
    openId: openId,
    ownOpenId: openId,  // App版本在版本层处理
    type: event.data.type,
    // 不传递source参数
  };
  
  // 3. 调用核心层
  const result = await cloud.callFunction({
    name: 'getDynsListV2',
    data: coreParams
  });
  
  // 4. 数据格式转换（App特有格式）
  return formatForApp(result);
}

// ========== 业务核心层（getDynsListV2/index.js）==========
exports.main = async (event, context) => {
  // 核心层不接收source参数
  // 统一接收标准化参数
  const { openId, ownOpenId, type } = event;
  
  // 核心业务逻辑（不区分来源）
  // ... 执行查询逻辑
  
  return result;
}

// ========== 小程序版本 ==========
// 小程序直接调用getDynsListV2
wx.cloud.callFunction({
  name: 'getDynsListV2',
  data: {
    openId: wxContext.OPENID,  // 小程序通过wxContext获取
    ownOpenId: wxContext.OPENID,
    type: 1
    // 不传source
  }
})
```

### 8.3 隔离保证

**完全隔离**：
- App和小程序使用不同的入口（appApi vs 直接调用）
- App版本在版本层处理所有差异
- 核心层不区分来源，保持纯净
- 互不影响，完全隔离

**数据一致性**：
- App和小程序共享数据库
- 核心层使用相同的业务逻辑操作数据
- 确保数据完全一致
- 会员状态字段完全一致

### 8.4 版本控制 vs Source判断对比

| 对比项 | Source判断方案 | 版本控制方案（推荐） |
|--------|---------------|-------------------|
| **核心层复杂度** | 需要if-else判断 | 保持纯净，无判断 |
| **可维护性** | 每个核心函数都要判断 | 核心层统一标准 |
| **可扩展性** | 新增版本需修改核心层 | 新增版本只需新增版本层 |
| **代码复用** | 部分复用 | 完全复用 |
| **职责清晰度** | 核心层关心来源 | 版本层处理差异，职责清晰 |
| **测试复杂度** | 需要测试不同source分支 | 核心层测试更简单 |

**结论**：版本控制方案更优，符合单一职责原则，可维护性和可扩展性更好。

## 九、开发注意事项

### 9.1 接口开发
- 所有App接口在appApi的业务版本层（modules）实现
- 版本层负责参数标准化、数据转换、业务差异处理
- 调用核心层时传递标准化参数，不传source
- 核心层保持纯净，不区分来源
- 确保小程序不受影响

### 9.2 会员状态
- 所有返回用户信息的接口必须包含会员状态
- 会员状态字段位置统一
- 会员状态实时获取
- 会员状态判断逻辑与小程序一致

### 9.3 测试验证
- 每个接口开发后都要测试
- 验证会员状态同步
- 验证小程序功能未受影响
- 对比App和小程序数据一致性

## 十、版本控制方案合理性分析

### 10.1 方案对比

**方案A：Source判断方案（旧方案）**
```javascript
// 核心层需要判断source
exports.main = async (event) => {
  if (event.source === 'app') {
    // App特有逻辑
    openId = event.openId;  // App传递的openId
  } else {
    // 小程序逻辑
    const wxContext = cloud.getWXContext();
    openId = wxContext.OPENID;
  }
  // 业务逻辑...
}
```

**方案B：版本控制方案（推荐）**
```javascript
// 核心层保持纯净
exports.main = async (event) => {
  // 统一接收标准化参数
  const { openId, ownOpenId } = event;
  // 业务逻辑（不区分来源）
  // ...
}

// 版本层处理差异
async function appGetDynList(event) {
  const { openId } = await verifyToken(event.token);  // App版本处理
  return await cloud.callFunction({
    name: 'getDynsListV2',
    data: { openId, ownOpenId: openId }  // 标准化参数
  });
}
```

### 10.2 版本控制方案的优势

#### ✅ 1. 符合单一职责原则
- **核心层**：只负责核心业务逻辑，不关心调用来源
- **版本层**：负责处理版本差异，参数转换，数据适配
- 职责清晰，易于理解和维护

#### ✅ 2. 更好的可维护性
- 核心层代码更简洁，无需if-else判断
- 版本差异集中在版本层，修改影响范围小
- 核心层修改不影响版本层，版本层修改不影响核心层

#### ✅ 3. 更强的可扩展性
- 新增版本（如H5、Android）只需新增版本层
- 核心层无需修改，保持稳定
- 版本层可以独立迭代，互不影响

#### ✅ 4. 更高的代码复用率
- 核心层可以被所有版本完全复用
- 不需要为不同版本维护多套核心逻辑
- 减少代码重复，提高代码质量

#### ✅ 5. 更简单的测试
- 核心层测试更简单，不需要测试不同source分支
- 版本层可以独立测试
- 测试覆盖更全面

#### ✅ 6. 更好的性能
- 核心层无需判断source，减少条件分支
- 代码执行路径更清晰
- 性能更优

### 10.3 实现要点

#### 1. 参数标准化
- 版本层将不同版本的参数转换为标准格式
- App版本：通过Token解析openId
- 小程序版本：通过wxContext获取openId
- 核心层统一接收标准化参数

#### 2. 数据格式转换
- 版本层负责数据格式转换
- 核心层返回标准数据格式
- 版本层转换为对应版本所需格式

#### 3. 业务差异处理
- App特有业务逻辑在版本层实现
- 核心层只处理通用业务逻辑
- 版本层可以独立实现，也可以调用核心层

### 10.4 迁移建议

**现有核心层改造步骤**：

1. **识别source判断逻辑**
   - 查找所有使用source参数的云函数
   - 识别source判断的代码块

2. **提取标准化参数**
   - 将source判断逻辑提取到版本层
   - 核心层统一接收标准化参数（openId等）

3. **版本层实现**
   - App版本在appApi的modules中实现
   - 处理Token验证、参数标准化、数据转换

4. **测试验证**
   - 确保App功能正常
   - 确保小程序功能不受影响
   - 确保数据一致性

### 10.5 结论

**版本控制方案完全合理，且优于source判断方案**：

- ✅ 符合软件工程最佳实践（单一职责、开闭原则）
- ✅ 架构更清晰，可维护性更强
- ✅ 扩展性更好，支持多版本迭代
- ✅ 代码质量更高，复用性更好
- ✅ 测试更简单，性能更优

**建议采用版本控制方案，去掉核心层的source判断。**

## 十一、架构评估

### 10.1 架构符合度评估

**与目标架构图的对比**：

| 架构层次 | 目标架构 | 当前实现 | 符合度 |
|---------|---------|---------|--------|
| 客户端层 | 入口/鉴权/参数适配 | appApi入口（Token验证、参数校验、响应格式化） | ✅ 完全符合 |
| 业务版本层 | 真正的差异在这里 | modules模块（版本控制，处理所有App特有逻辑） | ✅ 完全符合 |
| 业务核心层 | 能共用就共用 | 现有云函数（版本控制，不区分来源，保持纯净） | ✅ 完全符合 |

**结论**：当前架构设计**完全符合**您提供的架构图，采用**版本控制方案**，核心层保持纯净，版本层处理差异，架构更加清晰和可维护。

### 10.2 架构优势

1. **清晰的层次划分**
   - 客户端层：统一入口、鉴权、参数适配
   - 业务版本层：版本控制，处理所有App特有逻辑和差异
   - 业务核心层：保持纯净，不区分来源，专注核心业务

2. **良好的扩展性**
   - App特有功能可在业务版本层独立实现
   - 不影响小程序现有功能
   - 未来新增版本（H5、Android等），核心层无需修改
   - 便于后续迭代和功能扩展

3. **强隔离性**
   - App和小程序完全隔离
   - 通过appApi统一入口，不直接调用小程序云函数
   - 版本层处理差异，核心层不关心来源
   - 数据共享但逻辑隔离

4. **高复用性**
   - 业务核心层完全复用，不区分来源
   - 版本控制方案，核心层代码更纯净
   - 减少重复代码，提高代码质量

5. **更好的可维护性**
   - 核心层无需if-else判断，代码更清晰
   - 版本差异集中在版本层，职责明确
   - 符合单一职责原则，易于维护

### 10.3 后续迭代支持能力评估

**✅ 支持场景**：

1. **App特有功能开发**
   - 可在业务版本层独立实现
   - 不影响小程序
   - 示例：App特有的推送通知、App特有的UI交互逻辑

2. **数据格式差异处理**
   - 业务版本层可转换数据格式
   - 适配App和小程序的不同需求
   - 示例：App需要额外的字段或不同的数据结构

3. **业务规则差异**
   - App和小程序可以有不同的业务规则
   - 在业务版本层处理差异
   - 示例：App的会员权益与小程序不同

4. **性能优化**
   - App可以独立优化接口性能
   - 可以缓存、批量处理等
   - 不影响小程序性能

5. **版本迭代**
   - App可以独立迭代，不受小程序影响
   - 可以快速响应App特有需求
   - 便于A/B测试和灰度发布

**⚠️ 注意事项**：

1. **业务版本层职责**
   - 明确区分：哪些逻辑放在业务版本层，哪些调用业务核心层
   - 避免过度封装，保持架构清晰

2. **数据一致性**
   - 虽然逻辑隔离，但数据必须保持一致
   - 会员状态、用户数据等必须同步

3. **代码维护**
   - 业务版本层代码需要良好维护
   - 避免与业务核心层逻辑重复

### 10.4 架构成熟度评估

| 评估维度 | 评分 | 说明 |
|---------|------|------|
| 架构清晰度 | ⭐⭐⭐⭐⭐ | 层次分明，职责清晰，版本控制方案更优 |
| 扩展性 | ⭐⭐⭐⭐⭐ | 支持App特有功能独立开发，新增版本无需修改核心层 |
| 隔离性 | ⭐⭐⭐⭐⭐ | App和小程序完全隔离，版本层处理差异 |
| 复用性 | ⭐⭐⭐⭐⭐ | 业务核心层完全复用，不区分来源 |
| 可维护性 | ⭐⭐⭐⭐⭐ | 核心层保持纯净，版本层职责明确，易于维护 |
| **总体评分** | **⭐⭐⭐⭐⭐** | **架构设计优秀，版本控制方案更合理，完全满足后续迭代需求** |

## 十二、后续开发步骤

### 步骤1：创建appApi云函数结构
- 创建云函数目录
- 创建入口文件
- 创建模块文件
- 创建工具文件

### 步骤2：实现基础功能
- 实现Token验证
- 实现统一响应格式
- 实现错误处理

### 步骤3：实现接口模块
- 按优先级实现各个模块
- 逐个实现接口
- 补充接口参数文档

### 步骤4：测试验证
- 测试所有接口
- 验证会员状态同步
- 验证小程序未受影响
